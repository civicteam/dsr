const _=require("lodash"),{isValidGlobalIdentifier,VC}=require("@identity.com/credential-commons"),{services,initServices}=require("./services"),config=services.container.Config,signer=services.container.Signer,SCHEMA_VERSION="1",VALID_OPERATORS=["$eq","$ne","$gt","$gte","$lt","$lte","$mod","$in","$nin","$not","$all","$or","$nor","$and","$regex","$where","$elemMatch","$exists"],VALID_AGGREGATORS=["$limit","$max","$min","$last","$first","$sort"],isLocal=a=>null!==a.match("(http://|https://)?(localhost|127.0.0.*)"),isValidEvidenceChannelDetails=a=>{let b=!0;return b=_.includes(["application/json","image/*","multipart-from"],a.accepts),b=b&&_.includes(["put","post"],a.method),b=b&&!_.isEmpty(a.url)&&(isLocal(a.url)||_.startsWith(a.url,"https")),b};class ScopeRequest{static credentialsMatchesRequest(a,b){let c=!0;const d=_.get(b,"credentialItems");if(_.isEmpty(d))throw new Error("invalid scopeRequest object");if(_.isEmpty(a))throw new Error("empty credentialItems param");return _.forEach(d,b=>{const d=_.find(a,{identifier:b.identifier});if(!d)return c=!1,!1;const e=VC.fromJSON(d),f=_.get(b,"constraints"),g=e.isMatch(f);if(!g)return c=!1,!1}),c}static validateConstraint(a){const b=_.keys(a);if(1!==b.length)throw new Error("Invalid Constraint Object - only one operator is allowed");if(!_.includes(VALID_OPERATORS,b[0]))throw new Error(`Invalid Constraint Object - ${b[0]} is not a valid operator`);if(_.isNil(a[b[0]]))throw new Error("Invalid Constraint Object - a constraint value is required");return!0}static validateAggregationFilter(a){const b=_.keys(a);if(1!==b.length)throw new Error("Invalid Constraint Object - only one operator is allowed");if(!_.includes(VALID_AGGREGATORS,b[0]))throw new Error(`Invalid Aggregate Object - ${b[0]} is not a valid filter`);if(_.isNil(a[b[0]]))throw new Error("Invalid Constraint Object - a constraint value is required");return!0}static isValidCredentialItemIdentifier(a){return isValidGlobalIdentifier(a)}static isValidCredentialIssuer(a){return a&&a.match(/^did:ethr:0x[a-fA-F0-9]{40}$/g)}static validateCredentialItems(a){return _.forEach(a,a=>{if(!_.isString(a)){if(_.isEmpty(a.identifier))throw new Error("CredentialItem identifier is required");if(!ScopeRequest.isValidCredentialItemIdentifier(a.identifier))throw new Error(`${a.identifier} is not valid CredentialItem identifier`);if(!_.isEmpty(a.constraints)){if(!_.isEmpty(a.constraints.meta)){if(!a.constraints.meta.issuer)throw new Error("The META issuer constraint is required");if(!ScopeRequest.isValidCredentialIssuer(a.constraints.meta.issuer.is.$eq))throw new Error(`${a.constraints.meta.issuer.is.$eq} is not a valid issuer`);if(a.constraints.meta.issued&&ScopeRequest.validateConstraint(a.constraints.meta.issued.is),a.constraints.meta.expiry&&ScopeRequest.validateConstraint(a.constraints.meta.expiry.is),a.identifier.startsWith("claim-")&&a.constraints.meta.noClaims)throw new Error("Cannot ask for Claims and also have the flag noClaimss equals true")}_.isEmpty(a.constraints.claims)||_.forEach(a.constraints.claims,a=>{if(_.isEmpty(a.path))throw new Error("Claim path is required");if(_.isEmpty(a.is))throw new Error("Claim constraint is required");ScopeRequest.validateConstraint(a.is)})}_.isEmpty(a.aggregate)||_.forEach(a.aggregate,a=>{ScopeRequest.validateAggregationFilter(a)})}else if(!ScopeRequest.isValidCredentialItemIdentifier(a))throw new Error(`${a} is not valid CredentialItem identifier`)}),!0}static validateChannelsConfig(a){if(!a.eventsURL)throw new Error("eventsURL is required");if(!isLocal(a.eventsURL)&&!_.startsWith(a.eventsURL,"https"))throw new Error("only HTTPS is supported for eventsURL");if(a.payloadURL&&!isLocal(a.payloadURL)&&!_.startsWith(a.payloadURL,"https"))throw new Error("only HTTPS is supported for payloadURL");if(a.evidences){if(a.evidences.idDocumentFront&&!isValidEvidenceChannelDetails(a.evidences.idDocumentFront))throw new Error("invalid idDocumentFront channel configuration");if(a.evidences.idDocumentBack&&!isValidEvidenceChannelDetails(a.evidences.idDocumentBack))throw new Error("invalid idDocumentBack channel configuration");if(a.evidences.selfie&&!isValidEvidenceChannelDetails(a.evidences.selfie))throw new Error("invalid selfie channel configuration")}return!0}static validateAppConfig(a){if(_.isEmpty(a.id))throw new Error("app.id is required");if(_.isEmpty(a.name))throw new Error("app.name is required");if(_.isEmpty(a.logo))throw new Error("app.logo is required");if(!_.startsWith(a.logo,"https"))throw new Error("only HTTPS is supported for app.logo");if(_.isEmpty(a.description))throw new Error("app.description is required");if(_.isEmpty(a.primaryColor))throw new Error("app.primaryColor is required");if(_.isEmpty(a.secondaryColor))throw new Error("app.secondaryColor is required");return!0}static validatePartnerConfig(a){if(_.isEmpty(a.id))throw new Error("partner.id is required");if(_.isEmpty(a.signingKeys)||_.isEmpty(a.signingKeys.xpub)||_.isEmpty(a.signingKeys.xprv))throw new Error("Partner public and private signing keys are required");return!0}static validateAuthentication(a){if(!_.isBoolean(a))throw new Error("Invalid value for authentication");return!0}constructor(a,b,c,d,e,f=!0){if(this.version=SCHEMA_VERSION,!a)throw Error("uniqueId is required");this.id=a,this.requesterInfo={},ScopeRequest.validateAuthentication(f)&&(this.authentication=f),this.timestamp=new Date().toISOString();const g=[].concat(b);if(ScopeRequest.validateCredentialItems(g)&&(this.credentialItems=_.cloneDeep(g)),c&&ScopeRequest.validateChannelsConfig(c))this.channels=c;else{const b={eventsURL:`${config.channels.baseEventsURL}/${a}`,payloadURL:`${config.channels.basePayloadURL}/${a}`};ScopeRequest.validateChannelsConfig(b)&&(this.channels=b)}if(d&&ScopeRequest.validateAppConfig(d)?this.requesterInfo.app=d:ScopeRequest.validateAppConfig(config.app)&&(this.requesterInfo.app=config.app),e&&ScopeRequest.validatePartnerConfig(e)){const a=Object.assign({},config);a.partner=e,initServices(a),this.requesterInfo.requesterId=e.id}else ScopeRequest.validatePartnerConfig(config.partner)&&(this.requesterInfo.requesterId=config.partner.id)}toJSON(){return _.omit(this,["partnerConfig"])}}function buildSignedRequestBody(a){const{xprv:b,xpub:c}=services.container.Config.partner.signingKeys,d=signer.sign(a,b);return{payload:a,signature:d.signature,algorithm:d.algorithm,xpub:c}}function verifySignedRequestBody(a,b){if(!a.payload)throw new Error("Request must have a payload object");if(!a.signature)throw new Error("Request must have a signature");if(!a.xpub)throw new Error("Request must have a public key");if(b&&b!==a.xpub)throw new Error("Request public key not match");return signer.verify(a.payload,a.signature,a.xpub)}module.exports={ScopeRequest,buildSignedRequestBody,verifySignedRequestBody};